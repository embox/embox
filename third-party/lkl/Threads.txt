### Как LKL работает с потоками хост-ОС
----
LKL использует Thread Local Storage (TLS) для того, чтобы различать хост-потоки. Во время инициализации LKL при помощи `lkl_ops->tls_alloc` создается `task_key` - общий для всех хост-потоков ключ, обращаясь к которому каждый поток может задавать/получать какое-либо уникальное для потока значение. В качестве значения используется указатель на Linux Task, а именно, на kernel_thread (kthread).

В `arch/lkl/kernel/syscalls.c` есть функция `lkl_syscall`. В какой-то момент в ней происходит обращение к TLS по ключу `task_key` и достается информация о kernel_thread (переменная `task`), соответствующему текущему хост-потоку, чтобы затем сделать `switch_to_host_task(task)`. Если информации нет (возвращается NULL), то это значит, что имеет место быть новый хост-поток, и нужно сделать `new_host_task(&task)` (там создается новый kernel_thread), добавляя после этого информацию о созданном kernel_thread в TLS при помощи `lkl_ops->tls_set(task_key, task)` (созданный kernel_thread ассоциируется с текущим хост-потоком).

### Текущее ограничение
----
Текущая ситуация такая: каждому процессу в Embox соответствует kthread в LKL. Но дело в том, что эти kthread-ы имеют много общих ресурсов (например, одна таблица файловых дескрипторов).

Можно легко отключить разделение __некоторых__ ресурсов так, что у каждого kthread будет свой ресурс. В частности, чтобы разделить таблицы файловых дескрипторов, нужно убрать `CLONE_FILES` из `CLONE_FLAGS` в `arch/lkl/kernel/syscalls.c:52`. Трюк с STDOUT-ом через /vda сломается, так-как у каждого нового kthread-а не будет сразу открытого файлового дескриптора #1, указывающего на /vda). Но это можно легко решить.

Однако, отключить разделение __всех__ ресурсов таким образом не получится. Видимо, в начале LKL создает несколько служебных kthreads, которые, как кажется, должны иметь что-то разделяемое. Иначе LKL не работает. Это можно обойти. Например, сделать `CLONE_FLAGS_2`, которые использовать именно на случай создания новых kthreads в связи с обнаружением новых Embox процессов. Но тут тоже могут возникнуть определенные трудности.

Это остается открытой задачей.

### Поддержка clone
----
ToDo: написать, как привить поддержку `lkl_sys_clone()`.


### Проблема с ключом Thread Local Storage
----
Проблема была в том, что в Embox инициализация LKL происходит в одной задаче (см. `embox/src/kernel/task/lkl_task.c`), а обращение к LKL, как к паравиртуализированному ядру Linux, происходит каждый раз из новых Embox процессов. Следовательно, когда мы обращаемся к TLS по ключу `task_key`, то `lkl_ops->tls_get` возвращает NULL. LKL думает, что это новый поток, но на самом деле у нас целый новый процесс. Поэтому когда LKL делает `lkl_ops->tls_set(task_key, task)`, этот вызов завершается неудачно (возвращает -1). Ведь для текущего процесса мы не делали `lkl_ops->tls_alloc`. И получается, что мы находимся на одном и том же хост-потоке, при этом переключаемся на новый kernel_thread (и так в каждый системный вызов).

Решение:
Если после `new_host_task` мы делаем `lkl_ops->tls_set(task_key, task)`, а он возвращает -1, то сделаем `task_key = lkl_ops->tls_alloc`, и снова повторим `lkl_ops->tls_set(task_key, task)`. Иными словами, "если не удался `tls_set`, то значит это новый процесс!".

Проверка:
Убедиться, что несколько вызовов `lkl_sys_gettid()` подряд в одном процессе возвращают одно значение. Иными словами, каждый новый системный вызов в LKL не приводит к созданию нового kthread.
