/* automatically generated by rust-bindgen 0.60.1 */

#![no_std]
#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]

pub const __llvm__: u32 = 1;
pub const __clang__: u32 = 1;
pub const __clang_major__: u32 = 6;
pub const __clang_minor__: u32 = 0;
pub const __clang_patchlevel__: u32 = 0;
pub const __clang_version__: &[u8; 31usize] = b"6.0.0 (tags/RELEASE_600/final)\0";
pub const __GNUC_MINOR__: u32 = 2;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __GNUC__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1002;
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM: u32 = 0;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP: u32 = 1;
pub const __OPENCL_MEMORY_SCOPE_DEVICE: u32 = 2;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES: u32 = 3;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP: u32 = 4;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __VERSION__: &[u8; 54usize] = b"4.2.1 Compatible Clang 6.0.0 (tags/RELEASE_600/final)\0";
pub const __OBJC_BOOL_IS_BOOL: u32 = 0;
pub const __CONSTANT_CFSTRINGS__: u32 = 1;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __LITTLE_ENDIAN__: u32 = 1;
pub const _LP64: u32 = 1;
pub const __LP64__: u32 = 1;
pub const __CHAR_BIT__: u32 = 8;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u64 = 9223372036854775807;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 2147483647;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __SIZE_MAX__: i32 = -1;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __PTRDIFF_MAX__: u64 = 9223372036854775807;
pub const __INTPTR_MAX__: u64 = 9223372036854775807;
pub const __UINTPTR_MAX__: i32 = -1;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 16;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_POINTER__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_PTRDIFF_T__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 8;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_INT128__: u32 = 16;
pub const __INTMAX_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __INTMAX_FMTi__: &[u8; 3usize] = b"li\0";
pub const __UINTMAX_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __UINTMAX_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __UINTMAX_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __UINTMAX_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __PTRDIFF_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __PTRDIFF_FMTi__: &[u8; 3usize] = b"li\0";
pub const __PTRDIFF_WIDTH__: u32 = 64;
pub const __INTPTR_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __INTPTR_FMTi__: &[u8; 3usize] = b"li\0";
pub const __INTPTR_WIDTH__: u32 = 64;
pub const __SIZE_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __SIZE_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __SIZE_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __SIZE_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __SIZE_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __UINTMAX_WIDTH__: u32 = 64;
pub const __UINTPTR_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __UINTPTR_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __UINTPTR_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __UINTPTR_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __UINTPTR_WIDTH__: u32 = 64;
pub const __FLT16_HAS_DENORM__: u32 = 1;
pub const __FLT16_DIG__: u32 = 3;
pub const __FLT16_DECIMAL_DIG__: u32 = 5;
pub const __FLT16_HAS_INFINITY__: u32 = 1;
pub const __FLT16_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT16_MANT_DIG__: u32 = 11;
pub const __FLT16_MAX_10_EXP__: u32 = 4;
pub const __FLT16_MAX_EXP__: u32 = 15;
pub const __FLT16_MIN_10_EXP__: i32 = -13;
pub const __FLT16_MIN_EXP__: i32 = -14;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_DIG__: u32 = 18;
pub const __LDBL_DECIMAL_DIG__: u32 = 21;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 64;
pub const __LDBL_MAX_10_EXP__: u32 = 4932;
pub const __LDBL_MAX_EXP__: u32 = 16384;
pub const __LDBL_MIN_10_EXP__: i32 = -4931;
pub const __LDBL_MIN_EXP__: i32 = -16381;
pub const __POINTER_WIDTH__: u32 = 64;
pub const __BIGGEST_ALIGNMENT__: u32 = 16;
pub const __WINT_UNSIGNED__: u32 = 1;
pub const __INT8_FMTd__: &[u8; 4usize] = b"hhd\0";
pub const __INT8_FMTi__: &[u8; 4usize] = b"hhi\0";
pub const __INT16_FMTd__: &[u8; 3usize] = b"hd\0";
pub const __INT16_FMTi__: &[u8; 3usize] = b"hi\0";
pub const __INT32_FMTd__: &[u8; 2usize] = b"d\0";
pub const __INT32_FMTi__: &[u8; 2usize] = b"i\0";
pub const __INT64_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __INT64_FMTi__: &[u8; 3usize] = b"li\0";
pub const __UINT8_FMTo__: &[u8; 4usize] = b"hho\0";
pub const __UINT8_FMTu__: &[u8; 4usize] = b"hhu\0";
pub const __UINT8_FMTx__: &[u8; 4usize] = b"hhx\0";
pub const __UINT8_FMTX__: &[u8; 4usize] = b"hhX\0";
pub const __UINT8_MAX__: u32 = 255;
pub const __INT8_MAX__: u32 = 127;
pub const __UINT16_FMTo__: &[u8; 3usize] = b"ho\0";
pub const __UINT16_FMTu__: &[u8; 3usize] = b"hu\0";
pub const __UINT16_FMTx__: &[u8; 3usize] = b"hx\0";
pub const __UINT16_FMTX__: &[u8; 3usize] = b"hX\0";
pub const __UINT16_MAX__: u32 = 65535;
pub const __INT16_MAX__: u32 = 32767;
pub const __UINT32_FMTo__: &[u8; 2usize] = b"o\0";
pub const __UINT32_FMTu__: &[u8; 2usize] = b"u\0";
pub const __UINT32_FMTx__: &[u8; 2usize] = b"x\0";
pub const __UINT32_FMTX__: &[u8; 2usize] = b"X\0";
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __UINT64_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __UINT64_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __UINT64_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __UINT64_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __UINT64_MAX__: i32 = -1;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_FMTd__: &[u8; 4usize] = b"hhd\0";
pub const __INT_LEAST8_FMTi__: &[u8; 4usize] = b"hhi\0";
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST8_FMTo__: &[u8; 4usize] = b"hho\0";
pub const __UINT_LEAST8_FMTu__: &[u8; 4usize] = b"hhu\0";
pub const __UINT_LEAST8_FMTx__: &[u8; 4usize] = b"hhx\0";
pub const __UINT_LEAST8_FMTX__: &[u8; 4usize] = b"hhX\0";
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_FMTd__: &[u8; 3usize] = b"hd\0";
pub const __INT_LEAST16_FMTi__: &[u8; 3usize] = b"hi\0";
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST16_FMTo__: &[u8; 3usize] = b"ho\0";
pub const __UINT_LEAST16_FMTu__: &[u8; 3usize] = b"hu\0";
pub const __UINT_LEAST16_FMTx__: &[u8; 3usize] = b"hx\0";
pub const __UINT_LEAST16_FMTX__: &[u8; 3usize] = b"hX\0";
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_FMTd__: &[u8; 2usize] = b"d\0";
pub const __INT_LEAST32_FMTi__: &[u8; 2usize] = b"i\0";
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST32_FMTo__: &[u8; 2usize] = b"o\0";
pub const __UINT_LEAST32_FMTu__: &[u8; 2usize] = b"u\0";
pub const __UINT_LEAST32_FMTx__: &[u8; 2usize] = b"x\0";
pub const __UINT_LEAST32_FMTX__: &[u8; 2usize] = b"X\0";
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __INT_LEAST64_FMTi__: &[u8; 3usize] = b"li\0";
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __UINT_LEAST64_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __UINT_LEAST64_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __UINT_LEAST64_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __UINT_LEAST64_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __INT_FAST8_MAX__: u32 = 127;
pub const __INT_FAST8_FMTd__: &[u8; 4usize] = b"hhd\0";
pub const __INT_FAST8_FMTi__: &[u8; 4usize] = b"hhi\0";
pub const __UINT_FAST8_MAX__: u32 = 255;
pub const __UINT_FAST8_FMTo__: &[u8; 4usize] = b"hho\0";
pub const __UINT_FAST8_FMTu__: &[u8; 4usize] = b"hhu\0";
pub const __UINT_FAST8_FMTx__: &[u8; 4usize] = b"hhx\0";
pub const __UINT_FAST8_FMTX__: &[u8; 4usize] = b"hhX\0";
pub const __INT_FAST16_MAX__: u32 = 32767;
pub const __INT_FAST16_FMTd__: &[u8; 3usize] = b"hd\0";
pub const __INT_FAST16_FMTi__: &[u8; 3usize] = b"hi\0";
pub const __UINT_FAST16_MAX__: u32 = 65535;
pub const __UINT_FAST16_FMTo__: &[u8; 3usize] = b"ho\0";
pub const __UINT_FAST16_FMTu__: &[u8; 3usize] = b"hu\0";
pub const __UINT_FAST16_FMTx__: &[u8; 3usize] = b"hx\0";
pub const __UINT_FAST16_FMTX__: &[u8; 3usize] = b"hX\0";
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_FMTd__: &[u8; 2usize] = b"d\0";
pub const __INT_FAST32_FMTi__: &[u8; 2usize] = b"i\0";
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_FMTo__: &[u8; 2usize] = b"o\0";
pub const __UINT_FAST32_FMTu__: &[u8; 2usize] = b"u\0";
pub const __UINT_FAST32_FMTx__: &[u8; 2usize] = b"x\0";
pub const __UINT_FAST32_FMTX__: &[u8; 2usize] = b"X\0";
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_FMTd__: &[u8; 3usize] = b"ld\0";
pub const __INT_FAST64_FMTi__: &[u8; 3usize] = b"li\0";
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __UINT_FAST64_FMTo__: &[u8; 3usize] = b"lo\0";
pub const __UINT_FAST64_FMTu__: &[u8; 3usize] = b"lu\0";
pub const __UINT_FAST64_FMTx__: &[u8; 3usize] = b"lx\0";
pub const __UINT_FAST64_FMTX__: &[u8; 3usize] = b"lX\0";
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __NO_INLINE__: u32 = 1;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_RADIX__: u32 = 2;
pub const __DECIMAL_DIG__: u32 = 21;
pub const __amd64__: u32 = 1;
pub const __amd64: u32 = 1;
pub const __x86_64: u32 = 1;
pub const __x86_64__: u32 = 1;
pub const __k8: u32 = 1;
pub const __k8__: u32 = 1;
pub const __tune_k8__: u32 = 1;
pub const __NO_MATH_INLINES: u32 = 1;
pub const __FXSR__: u32 = 1;
pub const __SSE2__: u32 = 1;
pub const __SSE2_MATH__: u32 = 1;
pub const __SSE__: u32 = 1;
pub const __SSE_MATH__: u32 = 1;
pub const __MMX__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: u32 = 1;
pub const __SIZEOF_FLOAT128__: u32 = 16;
pub const unix: u32 = 1;
pub const __unix: u32 = 1;
pub const __unix__: u32 = 1;
pub const linux: u32 = 1;
pub const __linux: u32 = 1;
pub const __linux__: u32 = 1;
pub const __gnu_linux__: u32 = 1;
pub const __ELF__: u32 = 1;
pub const __FLOAT128__: u32 = 1;
pub const __STDC__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const EOF: i32 = -1;
pub const _IONBF: u32 = 0;
pub const _IOFBF: u32 = 1;
pub const _IOLBF: u32 = 2;
pub const BUFSIZ: u32 = 256;
pub const L_tmpnam: u32 = 32;
pub const FILENAME_MAX: u32 = 32;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TASKST_EXITED_MASK: u32 = 256;
pub const TASKST_EXITST_MASK: u32 = 255;
pub const TASKST_SIGNALD_MASK: u32 = 512;
pub const TASKST_TERMSIG_MASK: u32 = 255;
pub const TASKST_STOPPED_MASK: u32 = 1024;
pub const TASKST_STOPSIG_MASK: u32 = 255;
pub const TASKST_CONT_MASK: u32 = 2048;
pub const TASK_STATUS_IN_VFORK: u32 = 4096;
pub const WCONTINUED: u32 = 1;
pub const WNOHANG: u32 = 2;
pub const WUNTRACED: u32 = 4;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -127;
pub const SCHAR_MAX: u32 = 128;
pub const UCHAR_MAX: u32 = 255;
pub const WORD_BIT: u32 = 32;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const LONG_BIT: u32 = 32;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const MB_LEN_MAX: u32 = 1;
pub const _CTYPE_U: u32 = 1;
pub const _CTYPE_L: u32 = 2;
pub const _CTYPE_D: u32 = 4;
pub const _CTYPE_C: u32 = 8;
pub const _CTYPE_P: u32 = 16;
pub const _CTYPE_S: u32 = 32;
pub const _CTYPE_X: u32 = 64;
pub const _CTYPE_SP: u32 = 128;
pub const INT8_MAX: u32 = 127;
pub const INT8_MIN: i32 = -128;
pub const UINT8_MAX: u32 = 255;
pub const INT16_MAX: u32 = 32767;
pub const INT16_MIN: i32 = -32768;
pub const UINT16_MAX: u32 = 65535;
pub const INT32_MAX: u32 = 2147483647;
pub const INT32_MIN: i32 = -2147483648;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST8_MIN: i32 = -128;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST8_MIN: i32 = -128;
pub const UINT_FAST8_MAX: u32 = 255;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST16_MIN: i32 = -32768;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const SSIZE_MAX: u32 = 0;
pub const WCHAR_MAX: u32 = 2147483647;
pub const WINT_MAX: u32 = 4294967295;
pub const RAND_MAX: u32 = 2147483647;
pub const MB_CUR_MAX: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub type size_t = ::core::ffi::c_ulong;
extern "C" {
    #[doc = " Calculates the length of the specified null-terminated string."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @return"]
    #[doc = "   String length (the offset of the terminating null character within the"]
    #[doc = "   array)."]
    pub fn strlen(str_: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Copies a null-terminated string from one location to another."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination buffer."]
    #[doc = " @param src"]
    #[doc = "   The string being copied."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " @see memcpy()"]
    pub fn strcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Copies up to @a n bytes of a string from one location to another adding"]
    #[doc = " zeros to the end of the copy if the source string length is less than @a n."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination buffer of length @a n."]
    #[doc = " @param src"]
    #[doc = "   The string being copied."]
    #[doc = " @param n"]
    #[doc = "   The number of bytes to fill in the destination buffer."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Despite the name this function is not a bounded version of #strcpy(),"]
    #[doc = "   it does not guarantee that the result is a null-terminated string."]
    pub fn strncpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Appends a null-terminated string to the end of another."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination null-terminated string to append the @a src to."]
    #[doc = " @param src"]
    #[doc = "   The string being appended."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination string."]
    pub fn strcat(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Appends no more than @a n  bytes of a null-terminated string to the end of"]
    #[doc = " another."]
    #[doc = " This function is a bounded version of #strcat()."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination null-terminated string to append the @a src to."]
    #[doc = " @param src"]
    #[doc = "   The string being appended."]
    #[doc = " @param n"]
    #[doc = "   Maximum number of symbols to copy."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination string."]
    pub fn strncat(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Compares two strings lexicographically."]
    #[doc = ""]
    #[doc = " @param str1"]
    #[doc = "   The first string."]
    #[doc = " @param str2"]
    #[doc = "   The second string."]
    #[doc = " @return"]
    #[doc = "   Comparison result according to the lexicographical order."]
    #[doc = " @retval 0"]
    #[doc = "   If the strings are equal."]
    #[doc = " @retval positive"]
    #[doc = "   If @a str1 is greater than @a str2."]
    #[doc = " @retval negative"]
    #[doc = "   If @a str1 is less than @a str2."]
    #[doc = ""]
    #[doc = " @see strncmp()"]
    pub fn strcmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Compares up to @c n bytes of two strings lexicographically."]
    #[doc = " This function is a bounded version of #strcmp()."]
    #[doc = ""]
    #[doc = " @param str1"]
    #[doc = "   The first string."]
    #[doc = " @param str2"]
    #[doc = "   The second string."]
    #[doc = " @param n"]
    #[doc = "   Maximum number of symbols to compare."]
    #[doc = " @return"]
    #[doc = "   Comparison result according to the lexicographical order."]
    #[doc = " @retval 0"]
    #[doc = "   If the strings are equal."]
    #[doc = " @retval positive"]
    #[doc = "   If @a str1 is greater than @a str2."]
    #[doc = " @retval negative"]
    #[doc = "   If @a str1 is less than @a str2."]
    #[doc = ""]
    #[doc = " @see strcmp()"]
    pub fn strncmp(
        str1: *const ::core::ffi::c_char,
        str2: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Compare two strings using C locale."]
    #[doc = " @param s1"]
    #[doc = "   The first string."]
    #[doc = " @param s2"]
    #[doc = "   The second string."]
    #[doc = " @return"]
    #[doc = "   Comparison result using LC_COLLATE=C."]
    #[doc = " @retval 0"]
    #[doc = "   If the strings are equal."]
    #[doc = " @retval positive"]
    #[doc = "   If @a s1 is greater than @a s2."]
    #[doc = " @retval negative"]
    #[doc = "   If @a s1 is less than @a s2."]
    #[doc = " Throw assert if character is not ASCII."]
    pub fn strcoll(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Copy no more than n symbols from src to dest in such way that"]
    #[doc = " strcmp with modified strings works in the same way as strcoll."]
    #[doc = " @param dest"]
    #[doc = "   Destination string."]
    #[doc = " @param s2"]
    #[doc = "   Source string."]
    #[doc = " @return"]
    #[doc = "   Number of bytes required to store the transformed string in"]
    #[doc = "   dest excluding the terminating null byte ('\\0')."]
    #[doc = " @retval 0"]
    #[doc = " Throw assert if character is not ASCII."]
    pub fn strxfrm(
        dest: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Finds the first occurrence of the character @a ch (converted to a @c char)"]
    #[doc = " in the given null-terminated string."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   The null-terminated string to search for @a ch occurrence."]
    #[doc = " @param ch"]
    #[doc = "   The character to search."]
    #[doc = " @return"]
    #[doc = "   Pointer to the located character in the specified string (if any)."]
    #[doc = " @retval NULL"]
    #[doc = "   If no match was found."]
    pub fn strchr(
        str_: *const ::core::ffi::c_char,
        ch: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Finds the first occurrence of the character @a ch (converted to a @c char)"]
    #[doc = " in the given null-terminated string."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   The null-terminated string to search for @a ch occurrence."]
    #[doc = " @param ch"]
    #[doc = "   The character to search."]
    #[doc = " @return"]
    #[doc = "   Pointer to the located character in the specified string (if any)."]
    #[doc = " @retval pointer to null-terminator '\\0'"]
    #[doc = "   If no match was found."]
    pub fn strchrnul(
        str_: *const ::core::ffi::c_char,
        ch: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Finds the last occurrence of the character @a ch in the given string."]
    #[doc = " This function is a reversed version of #strchr()."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   The null-terminated string to search for @a ch occurrence."]
    #[doc = " @param ch"]
    #[doc = "   The character to search."]
    #[doc = " @return"]
    #[doc = "   Pointer to the located character in the specified string (if any)."]
    #[doc = " @retval NULL"]
    #[doc = "   If no match was found."]
    #[doc = ""]
    #[doc = " @see strchr()"]
    pub fn strrchr(
        str_: *const ::core::ffi::c_char,
        ch: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Finds the first occurrence of the substring @a needle in"]
    #[doc = " the given null-terminated string @a haystack."]
    #[doc = ""]
    #[doc = " @param haystack"]
    #[doc = "   The null-terminated string to search for @a needle occurrence."]
    #[doc = " @param needle"]
    #[doc = "   The substring to search."]
    #[doc = " @return"]
    #[doc = "   Pointer into the @a haystack that is the first character of the located"]
    #[doc = "   substring (if any). Returns @a haystack if @a needle is empty."]
    #[doc = " @retval NULL"]
    #[doc = "   If no match was found."]
    pub fn strstr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Finds the first occurrence of the substring @a needle in"]
    #[doc = " the given null-terminated string @a haystack, but ignores case of both"]
    #[doc = " arguments."]
    #[doc = ""]
    #[doc = " @param haystack"]
    #[doc = "   The null-terminated string to search for @a needle occurrence."]
    #[doc = " @param needle"]
    #[doc = "   The substring to search."]
    #[doc = " @return"]
    #[doc = "   Pointer into the @a haystack that is the first character of the located"]
    #[doc = "   substring (if any). Returns @a haystack if @a needle is empty."]
    #[doc = " @retval NULL"]
    #[doc = "   If no match was found."]
    pub fn strcasestr(
        haystack: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Maps given error code to its string representation."]
    #[doc = ""]
    #[doc = " @param errno"]
    #[doc = "   The error code."]
    #[doc = " @return"]
    #[doc = "   C-style string, containing a descriptive error message"]
    pub fn strerror(err: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Copies no more than @a n bytes from memory area @a src"]
    #[doc = " to memory area @a dest,"]
    #[doc = " stopping when the character @a c is found."]
    #[doc = ""]
    #[doc = " @param dest"]
    #[doc = "  Destination buffer"]
    #[doc = " @param src"]
    #[doc = "  The object in memory being copied"]
    #[doc = " @param n"]
    #[doc = "  The number of bytes to copy"]
    #[doc = " @param c"]
    #[doc = "  Character to stop copying when found."]
    #[doc = " @return"]
    #[doc = "  Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "  If the memory areas overlap, the results are undefined."]
    #[doc = " @see memcpy()"]
    #[doc = "  It does the same thing, but it doesn't stop at c."]
    pub fn memccpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Copies @a n bytes from @a src to @a dst which must be two non-overlapping"]
    #[doc = " buffers."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination buffer."]
    #[doc = " @param src"]
    #[doc = "   The object in memory being copied."]
    #[doc = " @param n"]
    #[doc = "   The number of bytes to copy."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination buffer."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   The behavior is undefined if the two arrays overlap."]
    #[doc = " @see memmove()"]
    #[doc = "   Use it instead if overlapping of @a src and @a dst is possible."]
    pub fn memcpy(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Copies @a n bytes from @a src to @a dst handling possible memory"]
    #[doc = " overlapping."]
    #[doc = ""]
    #[doc = " @param dst"]
    #[doc = "   Destination buffer."]
    #[doc = " @param src"]
    #[doc = "   The object in memory being copied."]
    #[doc = " @param n"]
    #[doc = "   The number of bytes to copy."]
    #[doc = " @return"]
    #[doc = "   Pointer to the destination buffer."]
    pub fn memmove(
        dst: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Fills @a n bytes of memory starting at given @a ptr with the value of @a c"]
    #[doc = " converted to @code unsigned char @endcode."]
    #[doc = ""]
    #[doc = " @param ptr"]
    #[doc = "   Pointer to the memory being filled."]
    #[doc = " @param c"]
    #[doc = "   The pattern"]
    #[doc = " @param n"]
    #[doc = "   The number of bytes to fill."]
    #[doc = " @return"]
    #[doc = "   Pointer to the buffer."]
    pub fn memset(
        ptr: *mut ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Compares the @c n bytes of memory beginning at @a ptr1 against the @c n"]
    #[doc = " bytes of memory beginning at @a ptr2."]
    #[doc = ""]
    #[doc = " @param ptr1"]
    #[doc = "   Pointer to the first memory block."]
    #[doc = " @param ptr2"]
    #[doc = "   Pointer to the second memory block."]
    #[doc = " @param n"]
    #[doc = "   Number of bytes to compare."]
    #[doc = " @return"]
    #[doc = "   The difference between the first differing pair of bytes (if any)."]
    #[doc = " @retval 0"]
    #[doc = "   If the memory blocks are equal."]
    #[doc = " @retval positive"]
    #[doc = "   If the first memory block is greater than the second."]
    #[doc = " @retval negative"]
    #[doc = "   If the first memory block is less than the second."]
    pub fn memcmp(
        ptr1: *const ::core::ffi::c_void,
        ptr2: *const ::core::ffi::c_void,
        n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Scans the first n bytes of the memory area pointed to by"]
    #[doc = " s for the character c."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   Pointer to the memory"]
    #[doc = " @param c"]
    #[doc = "   The character to search"]
    #[doc = " @param n"]
    #[doc = "   Number of bytes to scan"]
    #[doc = " @return"]
    #[doc = "   Pointer to the matching byte"]
    #[doc = " @retval NULL the character doesn't occur in the given memory area"]
    pub fn memchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Scans the memory area pointed to by s in backward for the character c."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   Pointer to the memory"]
    #[doc = " @param c"]
    #[doc = "   The character to search"]
    #[doc = " @param n"]
    #[doc = "   Number of bytes to scan"]
    #[doc = " @return"]
    #[doc = "   Pointer to the matching byte"]
    #[doc = " @retval NULL the character doesn't occur in the given memory area"]
    pub fn memrchr(
        s: *const ::core::ffi::c_void,
        c: ::core::ffi::c_int,
        n: size_t,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " map upper-case characters in a string to lower-case."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @return"]
    #[doc = "   C-style null-terminated string."]
    pub fn strlwr(str_: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " map lower-case characters in a string to upper-case."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @return"]
    #[doc = "   C-style null-terminated string."]
    pub fn strupr(str_: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Calculate the length of the initial segment of s which"]
    #[doc = " consists entirely of characters in accept"]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @param accept"]
    #[doc = " @return"]
    #[doc = "   Number of characters in the initial segment"]
    #[doc = "   of s which consist only of characters from accept"]
    pub fn strspn(
        s: *const ::core::ffi::c_char,
        accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Calculate the length of the initial segment of s which"]
    #[doc = " consists entirely of characters not in reject"]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @param reject"]
    #[doc = " @return"]
    #[doc = "   Number of characters in the initial segment"]
    #[doc = "   of s which are not in the string reject"]
    pub fn strcspn(
        s: *const ::core::ffi::c_char,
        reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Locate the first occurrence in the string s of any of"]
    #[doc = " the characters in the string accept"]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "   C-style null-terminated string."]
    #[doc = " @param accept"]
    #[doc = " @return"]
    #[doc = "   Pointer to the character in s that matches one of the"]
    #[doc = "   characters in accept"]
    #[doc = " @retval NULL no such character is found"]
    pub fn strpbrk(
        s: *const ::core::ffi::c_char,
        accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a pointer to a new string which is a duplicate of the string s."]
    #[doc = " Memory for the new string is obtained with malloc, and can be freed with free."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = "  C-style null-terminated string."]
    #[doc = " @return"]
    #[doc = "   Pointer to a new string which is a duplicate of the string s"]
    pub fn strdup(s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " The function strtok_r() considers the null-terminated string s as a sequence"]
    #[doc = " of zero or more text tokens separated by spans of one or more characters"]
    #[doc = " from the separator string sep. The argument lasts points to a user-provided"]
    #[doc = " pointer which points to stored information necessary for strtok_r() to"]
    #[doc = " continue scanning the same string."]
    #[doc = " In the first call to strtok_r(), s points to a null-terminated string, sep"]
    #[doc = " to a null-terminated string of separator characters and the value pointed to"]
    #[doc = " by lasts is ignored. The function strtok_r() returns a pointer to the first"]
    #[doc = " character of the first token, writes a null character into s immediately"]
    #[doc = " following the returned token, and updates the pointer to which lasts points."]
    #[doc = " In subsequent calls, s is a NULL pointer and lasts will be unchanged from the previous call so that subsequent calls will move through the string s, returning successive tokens until no tokens remain. The separator string sep may be different from call to call. When no token remains in s, a NULL pointer is returned."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = " @param delim"]
    #[doc = " @param saveptr"]
    #[doc = " @return The function strtok_r() returns a pointer to the token found, or a"]
    #[doc = " NULL pointer when no token is found."]
    pub fn strtok_r(
        str_: *mut ::core::ffi::c_char,
        delim: *const ::core::ffi::c_char,
        saveptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " A sequence of calls to strtok() breaks the string pointed to by s1 into a"]
    #[doc = " sequence of tokens, each of which is delimited by a byte from the string"]
    #[doc = " pointed to by s2. The first call in the sequence has s1 as its first"]
    #[doc = " argument, and is followed by calls with a null pointer as their first"]
    #[doc = " argument. The separator string pointed to by s2 may be different from call"]
    #[doc = " to call."]
    #[doc = " The first call in the sequence searches the string pointed to by s1 for the"]
    #[doc = " first byte that is not contained in the current separator string pointed to"]
    #[doc = " by s2. If no such byte is found, then there are no tokens in the string"]
    #[doc = " pointed to by s1 and strtok() returns a null pointer. If such a byte is"]
    #[doc = " found, it is the start of the first token."]
    #[doc = " The strtok() function then searches from there for a byte that is contained"]
    #[doc = " in the current separator string. If no such byte is found, the current token"]
    #[doc = " extends to the end of the string pointed to by s1, and subsequent searches"]
    #[doc = " for a token will return a null pointer. If such a byte is found, it is"]
    #[doc = " overwritten by a null byte, which terminates the current token. The strtok()"]
    #[doc = " function saves a pointer to the following byte, from which the next search"]
    #[doc = " for a token will start."]
    #[doc = " Each subsequent call, with a null pointer as the value of the first argument,"]
    #[doc = " starts searching from the saved pointer and behaves as described above."]
    #[doc = ""]
    #[doc = " @param str"]
    #[doc = " @param delim"]
    #[doc = " @return Upon successful completion, strtok() returns a pointer to the first"]
    #[doc = " byte of a token. Otherwise, if there is no token, strtok() returns a null"]
    #[doc = " pointer."]
    pub fn strtok(
        str_: *mut ::core::ffi::c_char,
        delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " The strnlen() function shall compute the smaller of the number of bytes in"]
    #[doc = " the array to which s points, not including the terminating NUL character,"]
    #[doc = " or the value of the maxlen argument. The strnlen() function shall never"]
    #[doc = " examine more than maxlen bytes of the array pointed to by s."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = " @param maxlen"]
    #[doc = ""]
    #[doc = " @return The strnlen() function shall return an integer containing the smaller"]
    #[doc = "  of either the length of the string pointed to by s or maxlen."]
    pub fn strnlen(s: *const ::core::ffi::c_char, maxlen: size_t) -> size_t;
}
extern "C" {
    #[doc = " The strndup() function shall be equivalent to the strdup() function,"]
    #[doc = " duplicating the provided s in a new block of memory allocated as if by using"]
    #[doc = " malloc(), with the exception being that strndup() copies at most size plus"]
    #[doc = " one bytes into the newly allocated memory, terminating the new string with a"]
    #[doc = " NUL character. If the length of s is larger than size, only size bytes shall"]
    #[doc = " be duplicated. If size is larger than the length of s, all bytes in s shall"]
    #[doc = " be copied into the new memory buffer, including the terminating NUL"]
    #[doc = " character. The newly created string shall always be properly terminated."]
    #[doc = ""]
    #[doc = " @param s"]
    #[doc = " @param size"]
    #[doc = " @return Upon successful completion, the strndup() function shall return a"]
    #[doc = " pointer to the newly allocated memory containing the duplicated string."]
    #[doc = " Otherwise, it shall return a null pointer and set errno to indicate the error."]
    pub fn strndup(
        s: *const ::core::ffi::c_char,
        size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        size: size_t,
    ) -> size_t;
}
pub type va_list = __builtin_va_list;
pub type __s8 = ::core::ffi::c_schar;
pub type __u8 = ::core::ffi::c_uchar;
pub type __s16 = ::core::ffi::c_short;
pub type __u16 = ::core::ffi::c_ushort;
pub type __s32 = ::core::ffi::c_int;
pub type __u32 = ::core::ffi::c_uint;
pub type __s64 = ::core::ffi::c_longlong;
pub type __u64 = ::core::ffi::c_ulonglong;
pub type __size_t = ::core::ffi::c_uint;
pub type __ptrdiff_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_ulong;
pub type __intptr_t = ::core::ffi::c_long;
pub type __s_fast = __s32;
pub type __u_fast = __u32;
#[doc = " Note also that 'size_t' is a typedef required by the ISO C standard"]
#[doc = "(it must be available if <stddef.h> is included). However, 'ssize_t'"]
#[doc = "does not exist in the C standard -- the standard 'ptrdiff_t'"]
#[doc = "typedef is nearly equivalent."]
pub type ssize_t = ::core::ffi::c_int;
pub type clock_t = ::core::ffi::c_ulong;
#[doc = " Used for time in microseconds."]
pub type useconds_t = ::core::ffi::c_ulong;
#[doc = " Used for time in microseconds."]
pub type suseconds_t = ::core::ffi::c_long;
pub type gfp_t = __u32;
pub type time_t = ::core::ffi::c_long;
pub type id_t = ::core::ffi::c_int;
pub type pid_t = ::core::ffi::c_int;
pub type dev_t = __u32;
pub type clockid_t = ::core::ffi::c_int;
pub type ino_t = ::core::ffi::c_uint;
pub type nlink_t = ::core::ffi::c_ushort;
pub type mode_t = ::core::ffi::c_uint;
pub type uid_t = ::core::ffi::c_ushort;
pub type gid_t = ::core::ffi::c_ushort;
pub type blkno_t = ::core::ffi::c_uint;
pub type off_t = ::core::ffi::c_longlong;
pub type loff_t = ::core::ffi::c_longlong;
pub type fsblkcnt_t = ::core::ffi::c_ulong;
pub type fsfilcnt_t = ::core::ffi::c_ulong;
pub type blkcnt_t = ::core::ffi::c_ulong;
pub type blksize_t = ::core::ffi::c_ulong;
pub type fpos_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file_struct {
    _unused: [u8; 0],
}
pub type FILE = file_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    _unused: [u8; 0],
}
extern "C" {
    pub fn putc(c: ::core::ffi::c_int, f: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc(c: ::core::ffi::c_int, f: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(f: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(f: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Writes the string s and a trailing newline to stdout."]
    pub fn puts(s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(s: *const ::core::ffi::c_char, f: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Read a line from stdin into the buffer pointed to by s until"]
    #[doc = " either a terminating newline or EOF"]
    pub fn gets(s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fgets(
        s: *mut ::core::ffi::c_char,
        n: ::core::ffi::c_int,
        stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(c: ::core::ffi::c_int, stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(s: *const ::core::ffi::c_char);
}
extern "C" {
    #[doc = " Write formatted output to stdout from the format string FORMAT."]
    pub fn printf(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(
        format: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to file stream from the format string FORMAT."]
    pub fn fprintf(f: *mut FILE, format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        f: *mut FILE,
        format: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        fildes: ::core::ffi::c_int,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to string, according to the format string FORMAT."]
    pub fn sprintf(
        s: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        s: *mut ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to string with specific size, according to the format string FORMAT."]
    pub fn snprintf(
        s: *mut ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        s: *mut ::core::ffi::c_char,
        n: ::core::ffi::c_ulong,
        format: *const ::core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        stream: *mut FILE,
        format: *const ::core::ffi::c_char,
        arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(
        format: *const ::core::ffi::c_char,
        arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        s: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin according to the format string FORMAT."]
    pub fn scanf(format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(stream: *mut FILE, format: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S, according to the format string FORMAT."]
    pub fn sscanf(
        out: *const ::core::ffi::c_char,
        format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Open the file whose name is the string pointed to by path"]
    #[doc = " and associates a stream with it."]
    pub fn fopen(path: *const ::core::ffi::c_char, mode: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " @brief Opens file descriptor with generic functions"]
    #[doc = ""]
    #[doc = " @param cookie Cookie that will be passed to functions"]
    #[doc = " @param readfn read-like function"]
    #[doc = " @param writefn write-like function"]
    #[doc = " @param seekfn seek-like function"]
    #[doc = " @param closefn close-like function"]
    #[doc = ""]
    #[doc = " @return FILE *"]
    pub fn funopen(
        cookie: *const ::core::ffi::c_void,
        readfn: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_char,
                arg3: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        writefn: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_char,
                arg3: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: fpos_t,
                arg3: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        closefn: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Opens the file whose file descriptor is the fd"]
    #[doc = " and associates a stream with it."]
    #[doc = " FIXME mode ignored"]
    pub fn fdopen(fd: ::core::ffi::c_int, mode: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " Opens the file whose name is the string pointed to by"]
    #[doc = " path and associates the stream pointed to by stream with it"]
    pub fn freopen(
        path: *const ::core::ffi::c_char,
        mode: *const ::core::ffi::c_char,
        stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Read nmemb elements of data, each size bytes long, from the stream"]
    #[doc = " pointed to by stream, storing them at the location given by ptr."]
    pub fn fwrite(
        ptr: *const ::core::ffi::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    #[doc = " Read nmemb elements of data, each size bytes long, from the stream"]
    #[doc = " pointed to by stream, storing them at the location given by ptr."]
    pub fn fread(
        ptr: *mut ::core::ffi::c_void,
        size: size_t,
        nmemb: size_t,
        stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    #[doc = " Function will flushes the stream pointed to by fp (writing any buffered"]
    #[doc = " output data using fflush(3)) and closes the underlying file descriptor."]
    pub fn fclose(fp: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Deletes a name from the file system."]
    pub fn remove(pathname: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Sets the file position indicator for the stream pointed to by stream."]
    #[doc = " The new position, measured in bytes, is obtained by adding offset bytes to"]
    #[doc = " the position specified by whence.  If whence is set to SEEK_SET, SEEK_CUR,"]
    #[doc = "  or SEEK_END, the offset is relative to the start of the file, the current"]
    #[doc = "  position indicator, or end-of-file, respectively"]
    pub fn fseek(
        stream: *mut FILE,
        offset: ::core::ffi::c_long,
        origin: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(
        stream: *mut FILE,
        offset: off_t,
        origin: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(stream: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn ftello(stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn fgetpos(stream: *mut FILE, pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(stream: *mut FILE, pos: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Sets the file position indicator for the stream pointed to by stream to the beginning of the file."]
    pub fn rewind(stream: *mut FILE);
}
extern "C" {
    #[doc = " Change the name or location of a file."]
    pub fn rename(
        oldpath: *const ::core::ffi::c_char,
        newpath: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " Manipulate the underlying device parameters of special files."]
    pub fn fioctl(fp: *mut FILE, request: ::core::ffi::c_int, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn fileno(stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr(stream: *mut FILE);
}
extern "C" {
    pub fn feof(stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(fp: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setvbuf(
        stream: *mut FILE,
        buf: *mut ::core::ffi::c_char,
        mode: ::core::ffi::c_int,
        size: size_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setbuffer(stream: *mut FILE, buf: *mut ::core::ffi::c_char, size: size_t);
}
extern "C" {
    pub fn setbuf(stream: *mut FILE, buf: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn asprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasprintf(
        strp: *mut *mut ::core::ffi::c_char,
        fmt: *const ::core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(
        command: *const ::core::ffi::c_char,
        type_: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
pub type wchar_t = ::core::ffi::c_int;
pub type wint_t = ::core::ffi::c_uint;
pub type wctype_t = ::core::ffi::c_int;
extern "C" {
    pub fn waitpid(
        pid: pid_t,
        status: *mut ::core::ffi::c_int,
        options: ::core::ffi::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn wait(status: *mut ::core::ffi::c_int) -> pid_t;
}
extern "C" {
    pub static mut _ctype_: [::core::ffi::c_uchar; 0usize];
}
pub type int_least8_t = ::core::ffi::c_schar;
pub type int_least16_t = ::core::ffi::c_short;
pub type int_least32_t = ::core::ffi::c_int;
pub type int_least64_t = ::core::ffi::c_long;
pub type uint_least8_t = ::core::ffi::c_uchar;
pub type uint_least16_t = ::core::ffi::c_ushort;
pub type uint_least32_t = ::core::ffi::c_uint;
pub type uint_least64_t = ::core::ffi::c_ulong;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type int_fast32_t = ::core::ffi::c_int;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = ::core::ffi::c_long;
pub type uintmax_t = ::core::ffi::c_ulong;
extern "C" {
    pub fn isspace(c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::core::ffi::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *mut i32;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *mut i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv() {
    assert_eq!(
        ::core::mem::size_of::<ldiv>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ldiv>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<ldiv>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!("Offset of field: ", stringify!(ldiv), "::", stringify!(rem))
        );
    }
    test_field_rem();
}
pub type ldiv_t = ldiv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv() {
    assert_eq!(
        ::core::mem::size_of::<lldiv>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<lldiv>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<lldiv>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
pub type lldiv_t = lldiv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div() {
    assert_eq!(
        ::core::mem::size_of::<div>(),
        8usize,
        concat!("Size of: ", stringify!(div))
    );
    assert_eq!(
        ::core::mem::align_of::<div>(),
        4usize,
        concat!("Alignment of ", stringify!(div))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<div>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(div), "::", stringify!(quot))
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<div>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!("Offset of field: ", stringify!(div), "::", stringify!(rem))
        );
    }
    test_field_rem();
}
pub type div_t = div;
extern "C" {
    #[doc = " Converts the initial part of the string in @a nptr to a long integer value"]
    #[doc = " according to the given @a base, which must be between 2 and 36 inclusive,"]
    #[doc = " or be the special value 0."]
    #[doc = ""]
    #[doc = " The remainder of the string is converted to a @code long int @endcode value"]
    #[doc = " in the obvious manner, stopping at the first character which is not a valid"]
    #[doc = " digit in the given @a base."]
    #[doc = ""]
    #[doc = " @param nptr"]
    #[doc = "   The string to parse. It may begin with an arbitrary amount of white space"]
    #[doc = "   (determined by #isspace()) followed by a single optional '+' or '-' sign."]
    #[doc = "   The string is interpreted until the first invalid character is"]
    #[doc = "   encountered."]
    #[doc = " @param endptr"]
    #[doc = "   If @a endptr is not @c NULL, the address of the first invalid character is"]
    #[doc = "   stored in @c *endptr."]
    #[doc = " @param base"]
    #[doc = "   The base of interpreted number."]
    #[doc = "   If @a base is zero or 16, the string may include a @c 0x prefix, and the"]
    #[doc = "   number will be read in base 16 (hex)."]
    #[doc = "   Otherwise, a zero base is taken as 10 (decimal) unless the next character"]
    #[doc = "   is @c '0', in which case it is taken as 8 (octal)."]
    #[doc = " @return"]
    #[doc = "   The parsed number bounded to @code [LONG_MIN..LONG_MAX] @endcode or zero"]
    #[doc = "   if there were no valid characters representing a number in the given"]
    #[doc = "   @a base."]
    pub fn strtol(
        nptr: *const ::core::ffi::c_char,
        endptr: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn strtoul(
        nptr: *const ::core::ffi::c_char,
        endptr: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strtoll(
        nptr: *const ::core::ffi::c_char,
        endptr: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
extern "C" {
    pub fn strtoull(
        nptr: *const ::core::ffi::c_char,
        endptr: *mut *mut ::core::ffi::c_char,
        base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
extern "C" {
    pub fn strtof(nptr: *const ::core::ffi::c_char, endptr: *mut *mut ::core::ffi::c_char) -> f32;
}
extern "C" {
    pub fn strtod(nptr: *const ::core::ffi::c_char, endptr: *mut *mut ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn strtold(nptr: *const ::core::ffi::c_char, endptr: *mut *mut ::core::ffi::c_char)
        -> u128;
}
extern "C" {
    pub fn atof(nptr: *const ::core::ffi::c_char) -> f64;
}
extern "C" {
    pub fn atoi(nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atol(nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn atoq(nptr: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
extern "C" {
    #[doc = " Convert integer to string."]
    #[doc = " Converts an integer value to a null-terminated string using the specified base and stores the result in the array given by buf parameter."]
    #[doc = " If num < 0, the resulting string is preceded with '-' (regardless of base). No prefix is used to explicitly specify the base."]
    #[doc = " @param num Number to convert."]
    #[doc = " @param buf Character array to store the result. This should be long enough to contain any possible value."]
    #[doc = " @param base Base for the conversion. 1 < base < 37."]
    #[doc = " @return Pointer to buf."]
    pub fn itoa(
        num: ::core::ffi::c_int,
        buf: *mut ::core::ffi::c_char,
        base: ::core::ffi::c_ushort,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn calloc(
        nmemb: ::core::ffi::c_ulong,
        size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn malloc(size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn free(ptr: *mut ::core::ffi::c_void);
}
extern "C" {
    pub fn realloc(
        ptr: *mut ::core::ffi::c_void,
        size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memalign(boundary: size_t, size: size_t) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn posix_memalign(
        memptr: *mut *mut ::core::ffi::c_void,
        alignment: size_t,
        size: size_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn qsort(
        base: *mut ::core::ffi::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn bsearch(
        key: *const ::core::ffi::c_void,
        base: *const ::core::ffi::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Find the smallest element, greater or equals to specified."]
    pub fn lower_bound(
        key: *const ::core::ffi::c_void,
        base: *const ::core::ffi::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    #[doc = " Find the smallest element, strictly greater than specified."]
    pub fn upper_bound(
        key: *const ::core::ffi::c_void,
        base: *const ::core::ffi::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rand_r(seedp: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srand(seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
extern "C" {
    pub fn srandom(seed: ::core::ffi::c_uint);
}
extern "C" {
    pub fn initstate(
        seed: ::core::ffi::c_uint,
        state: *mut ::core::ffi::c_char,
        n: size_t,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn setstate(state: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::core::ffi::c_int,
    pub rand_deg: ::core::ffi::c_int,
    pub rand_sep: ::core::ffi::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    fn test_field_fptr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(fptr)
            )
        );
    }
    test_field_fptr();
    fn test_field_rptr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rptr)
            )
        );
    }
    test_field_rptr();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_rand_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_type)
            )
        );
    }
    test_field_rand_type();
    fn test_field_rand_deg() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_deg)
            )
        );
    }
    test_field_rand_deg();
    fn test_field_rand_sep() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(rand_sep)
            )
        );
    }
    test_field_rand_sep();
    fn test_field_end_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<random_data>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(random_data),
                "::",
                stringify!(end_ptr)
            )
        );
    }
    test_field_end_ptr();
}
extern "C" {
    pub fn random_r(buf: *mut random_data, result: *mut i32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn srandom_r(seed: ::core::ffi::c_uint, buf: *mut random_data) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn initstate_r(
        seed: ::core::ffi::c_uint,
        statebuf: *mut ::core::ffi::c_char,
        statelen: size_t,
        buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setstate_r(
        statebuf: *mut ::core::ffi::c_char,
        buf: *mut random_data,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn lldiv(num: ::core::ffi::c_longlong, denom: ::core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ldiv(num: ::core::ffi::c_long, denom: ::core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn div(num: ::core::ffi::c_int, denom: ::core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn exit(status: ::core::ffi::c_int);
}
extern "C" {
    pub fn _Exit(status: ::core::ffi::c_int);
}
extern "C" {
    pub fn getenv(name: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putenv(string: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setenv(
        envname: *const ::core::ffi::c_char,
        envval: *const ::core::ffi::c_char,
        overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn unsetenv(name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearenv() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn system(command: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mkstemp(path_template: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn realpath(
        file_name: *const ::core::ffi::c_char,
        resolved_name: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn mbtowc(
        out: *mut wchar_t,
        in_: *const ::core::ffi::c_char,
        n: size_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wctomb(out: *mut ::core::ffi::c_char, in_: *const wchar_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mblen(str_: *const ::core::ffi::c_char, max: size_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn atexit(func: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn mbstowcs(
        wcstring: *mut wchar_t,
        mbstring: *const ::core::ffi::c_char,
        n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(mbstr: *mut ::core::ffi::c_char, wcstr: *const wchar_t, max: size_t) -> size_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
